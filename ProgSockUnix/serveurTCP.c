/*
 * Auteur(s): ZHEN Cheng
 *
 */

#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/un.h>
#include <errno.h>

#define BUFSIZE 512
#define LISTEN_BACKLOG 50

int main(int argc, char **argv) {
    int sfd, s, ns, r;
    char buf[BUFSIZE];
    ssize_t nread, nwrite;
    struct sockaddr_un from;
    socklen_t fromlen;
    char host[NI_MAXHOST];
    char *message = "Message a envoyer: ";
    struct sockaddr_un a;
    char *sockname;    /* nom de la socket */

    if (argc != 2) {
        printf("Utilisation:\n\t%s <Unix socket path>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Creation de la socket */
    if ((sfd = socket(PF_UNIX, SOCK_SEQPACKET, 0)) < 0) {
        perror("socket()");
        exit(EXIT_FAILURE);
    }

    memset(&a, 0, sizeof(a)); /* nettoyage de la structure */
    a.sun_family = AF_UNIX;   /* famille de l'adresse */
    sockname = strncpy(a.sun_path, argv[1], sizeof(a.sun_path) - 1);

    /* Association d'un port a la socket */
    if (bind(sfd, (const struct sockaddr *) &a, sizeof(struct sockaddr_un)) < 0) {
        perror("bind()");
        close(sfd);
        exit(EXIT_FAILURE);
    }

    /* Positionnement de la machine a etats TCP sur listen */
    listen(sfd, LISTEN_BACKLOG);

    for (;;) {
        /* Acceptation de connexions */
        fromlen = sizeof(from);
        ns = accept(sfd, (struct sockaddr *) &from, &fromlen);
        if (ns == -1) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        /* Reconnaissance de la machine cliente */
        s = getnameinfo((struct sockaddr *) &from, fromlen,
                        host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
        if (s == 0)
            printf("Debut avec client '%s'\n", host);
        else
            fprintf(stderr, "getnameinfo: %s\n", gai_strerror(s));

        for (;;) {
            nwrite = write(ns, message, strlen(message));
            if (nwrite < 0) {
                perror("write");
                close(ns);
                break;
            }
            nread = read(ns, buf, BUFSIZE);
            if (nread == 0) {
                printf("Fin avec client '%s'\n", host);
                close(ns);
                break;
            } else if (nread < 0) {
                perror("read");
                close(ns);
                break;
            }
            buf[nread] = '\0';
            printf("Message recu '%s'\n", buf);
        }
    }
}
