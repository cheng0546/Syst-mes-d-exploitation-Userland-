/*
 * Auteur(s): ZHEN Cheng
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <pthread.h>
#include <assert.h>
#include <sys/time.h>

long double sum = 0.0;

/* Callback, lorsque des taches sont executees */
typedef struct worker {
    void *(*process) (void *arg);
    void *arg;
    struct worker *next;
} CThread_worker;

typedef struct {  /* Structure de pool de threads */
    pthread_mutex_t queue_lock;
    pthread_cond_t queue_ready;
    CThread_worker *queue_head;

    /* Si supprimer le pool de threads */
    int shutdown;
    pthread_t *threadid;

    /* Nombre de threads qui peuvent etre actives */
    int max_thread_num;

    /* NOmbre de taches dans la queue d'attente */
    int cur_queue_size;
} CThread_pool;

int pool_add_worker (void *(*process) (void *arg), void *arg);
void *thread_routine (void *arg);

static CThread_pool *pool = NULL;
void pool_init (int max_thread_num) {
    pool = (CThread_pool *) malloc (sizeof (CThread_pool));

    pthread_mutex_init (&(pool->queue_lock), NULL);
    pthread_cond_init (&(pool->queue_ready), NULL);

    pool->queue_head = NULL;

    pool->max_thread_num = max_thread_num;
    pool->cur_queue_size = 0;

    pool->shutdown = 0;

    pool->threadid = (pthread_t *) malloc (max_thread_num * sizeof (pthread_t));
    int i = 0;
    for (i = 0; i < max_thread_num; i++)     {
        pthread_create (&(pool->threadid[i]), NULL, thread_routine,NULL);
    }
}

/* Ajouter les taches dans le pool de threads */
int pool_add_worker (void *(*process) (void *arg), void *arg) {
    CThread_worker *newworker = (CThread_worker *) malloc (sizeof (CThread_worker));
    newworker->process = process;
    newworker->arg = arg;
    newworker->next = NULL;

    pthread_mutex_lock (&(pool->queue_lock));
    CThread_worker *member = pool->queue_head;
    if (member != NULL) {
        while (member->next != NULL)
            member = member->next;
        member->next = newworker;
    } else {
        pool->queue_head = newworker;
    }

    assert (pool->queue_head != NULL);

    pool->cur_queue_size++;
    pthread_mutex_unlock (&(pool->queue_lock));
    /* Apres avoir une tache dans la queue d'attente, activer un thread */
    pthread_cond_signal (&(pool->queue_ready));
    return 0;
}

/* Destruction du pool de threads */
int pool_destroy () {
    if (pool->shutdown)
        return -1;  /* Eviter d'etre appele 2 fois */
    pool->shutdown = 1;

    pthread_cond_broadcast (&(pool->queue_ready));

    int i;
    for (i = 0; i < pool->max_thread_num; i++)
        pthread_join (pool->threadid[i], NULL);
    free (pool->threadid);

    CThread_worker *head = NULL;
    while (pool->queue_head != NULL)
    {
        head = pool->queue_head;
        pool->queue_head = pool->queue_head->next;
        free (head);
    }

    pthread_mutex_destroy(&(pool->queue_lock));
    pthread_cond_destroy(&(pool->queue_ready));

    free (pool);

    pool=NULL;
    return 0;
}



void *thread_routine (void *arg) {
    printf ("starting thread 0x%lx\n", pthread_self ());
    while (1) {
        pthread_mutex_lock (&(pool->queue_lock));

        while (pool->cur_queue_size == 0 && !pool->shutdown) {
            printf ("thread 0x%lx is waiting\n", pthread_self ());
            pthread_cond_wait (&(pool->queue_ready), &(pool->queue_lock));
        }

        if (pool->shutdown) {
            pthread_mutex_unlock (&(pool->queue_lock));
            printf ("thread 0x%lx will exit\n", pthread_self ());
            pthread_exit (NULL);
        }

        printf ("thread 0x%lx is starting to work\n", pthread_self ());

        assert (pool->cur_queue_size != 0);
        assert (pool->queue_head != NULL);

        pool->cur_queue_size--;
        CThread_worker *worker = pool->queue_head;
        pool->queue_head = worker->next;
        pthread_mutex_unlock (&(pool->queue_lock));

        (*(worker->process)) (worker->arg);
        free (worker);
        worker = NULL;
    }

    pthread_exit (NULL);
}

/* Calcul de PI */
void *simple_sum (void *arg)
{
    printf ("threadid is 0x%lx, working on task %d\n", pthread_self (),*(int *) arg);

    unsigned long long i;
    long double sign = 1.0;

    for (i = *(int *) arg * 10000000; i < (*(int *) arg + 1) * 10000000; i++, sign = -sign) {
        sum += sign / (2.0 * i + 1.0 );
    }
    printf("sum = %.20Lf\n ", 4.0 * sum);

    return NULL;
}

int main (int argc, char **argv)
{
    struct timeval start, end;
    unsigned long diff;

    gettimeofday(&start, NULL);

    pool_init (10);/* Nombre de threads max dans le pool de threads */

    int *workingnum = (int *) malloc (sizeof (int) * 10);
    int i;
    for (i = 0; i < 10; i++)
    {
        workingnum[i] = i;
        pool_add_worker(simple_sum, &workingnum[i]);
    }
    sleep(3);

    pool_destroy ();

    gettimeofday(&end, NULL);
    diff = 1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;
    printf("pi = %.20Lf\n ", 4.0 * sum);
    printf("passed time = %ld\n", diff);

    free (workingnum);
    exit(EXIT_SUCCESS);
}
